"use strict";
// Copyright 2021-2025 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.fastifyConnectPlugin = fastifyConnectPlugin;
const connect_1 = require("@connectrpc/connect");
const protocol_1 = require("@connectrpc/connect/protocol");
const protoConnect = require("@connectrpc/connect/protocol-connect");
const protoGrpcWeb = require("@connectrpc/connect/protocol-grpc-web");
const protoGrpc = require("@connectrpc/connect/protocol-grpc");
const connect_node_1 = require("@connectrpc/connect-node");
/**
 * Plug your Connect routes into a Fastify server.
 */
function fastifyConnectPlugin(instance, opts, done) {
    if (opts.routes === undefined) {
        done();
        return;
    }
    if (opts.acceptCompression === undefined) {
        opts.acceptCompression = [connect_node_1.compressionGzip, connect_node_1.compressionBrotli];
    }
    if (opts.shutdownTimeoutMs !== undefined) {
        const shutdownController = (0, protocol_1.createLinkedAbortController)(opts.shutdownSignal);
        opts.shutdownSignal = shutdownController.signal;
        instance.addHook("preClose", (done) => {
            setTimeout(() => {
                shutdownController.abort(opts.shutdownError);
            }, opts.shutdownTimeoutMs);
            done();
        });
    }
    const router = (0, connect_1.createConnectRouter)(opts);
    opts.routes(router);
    const uHandlers = router.handlers;
    if (uHandlers.length == 0) {
        done();
        return;
    }
    // we can override all content type parsers (including application/json) in
    // this plugin without affecting outer scope
    addNoopContentTypeParsers(instance);
    for (const uHandler of uHandlers) {
        instance.all(uHandler.requestPath, {}, async function handleFastifyRequest(req, reply) {
            var _a;
            try {
                const uRes = await uHandler((0, connect_node_1.universalRequestFromNodeRequest)(req.raw, reply.raw, req.body, (_a = opts.contextValues) === null || _a === void 0 ? void 0 : _a.call(opts, req)));
                // Fastify maintains response headers on the reply object and only moves them to
                // the raw response during reply.send, but we are not using reply.send with this plugin.
                // So we need to manually copy them to the raw response before handing off to vanilla Node.
                for (const [key, value] of Object.entries(reply.getHeaders())) {
                    if (value !== undefined) {
                        reply.raw.setHeader(key, value);
                    }
                }
                await (0, connect_node_1.universalResponseToNodeResponse)(uRes, reply.raw);
            }
            catch (e) {
                if (connect_1.ConnectError.from(e).code == connect_1.Code.Aborted) {
                    return;
                }
                console.error(`handler for rpc ${uHandler.method.name} of ${uHandler.service.typeName} failed`, e);
            }
        });
    }
    done();
}
/**
 * Registers fastify content type parsers that do nothing for all content-types
 * known to Connect.
 */
function addNoopContentTypeParsers(instance) {
    instance.addContentTypeParser([
        protoConnect.contentTypeUnaryJson,
        protoConnect.contentTypeStreamJson,
        protoGrpcWeb.contentTypeProto,
        protoGrpcWeb.contentTypeJson,
        protoGrpc.contentTypeProto,
        protoGrpc.contentTypeJson,
    ], noopContentTypeParser);
    instance.addContentTypeParser(protoGrpc.contentTypeRegExp, noopContentTypeParser);
    instance.addContentTypeParser(protoGrpcWeb.contentTypeRegExp, noopContentTypeParser);
    instance.addContentTypeParser(protoConnect.contentTypeRegExp, noopContentTypeParser);
}
function noopContentTypeParser(_req, _payload, done) {
    done(null, undefined);
}
